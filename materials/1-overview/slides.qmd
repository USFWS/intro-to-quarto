---
title: |
   | Introduction 
   | to Quarto
subtitle: "Overview"
format: 
  refuge-revealjs:
    title-slide-attributes:
      data-background-image: "images/plover_title.png"
      data-background-size: 20%, cover
      data-background-position: "60% 50%, center"
    footer: "[Intro to Quarto](index.html){.small}"
editor: source
---

```{r}
#| echo: false
library(countdown)
```


## {.center}

[Course materials can be found at:]{.large}  
[https://github.com/USFWS/intro-to-quarto](https://github.com/USFWS/intro-to-quarto) [{{< fa brands github >}}](https://github.com/USFWS/intro-to-quarto).

::: {.notes}
- You can find the course materials at the website listed here.
:::


## Outline {.center}

- Overview of Quarto
- Components of a Quarto document
  - YAML metadata
  - Document body
  - Code blocks

::: {.notes}
- This workshop serves as an introduction to using Quarto to create reports.
- During our time here, we will provide a brief overview of what Quarto is, what it can do for you, and how it compares to R Markdown. We will then dive into the anatomy of a Quarto file, which can be broken into three primary components: the YAML metadata, the document body, and code blocks (or code "chunks").
- The workshop is a series of short presentations followed by hand-on exercises to practice what you've learned.
- We will be available to provide help during the exercises, so let us know by raising your hand (in person or virtually!)
:::


# The powers of <br> ![](images/super_quarto.png){width=600 fig-alt="Superman holding a pencil with city buildings in the background and Quarto written below him"} {.dark}

::: {.notes}
- Ok, let's dive into the world of creating documents using Quarto.
- Quarto is a multi-language next generation version of R Markdown.
- What can you do with Quarto?
    - Generate dynamic output using R. Python, and other languages that can be regenerated when the data change.
    - Has support for equations and citations.
    - Integrates well into RStudio and other code editors
    - Can create interactive documents by embedding html widgets and Shiny.
- It's quite powerful!
:::


## Outputs: [Documents]{.gray-bold}

::: {.center}
{{< pdf images/example_report.pdf width=75% height=775 >}}
:::

::: {.notes}
- Quarto can produce high quality documents in HTML, PDF or MS Word
- Has the ability to output content using standardized templates, as shown here for a refuge report.
:::


## Output: [Websites]{.gray-bold}

```{=html}
<iframe width="1600" height="800" src="https://usfws.github.io/Science_Applications_Metadata_Guidance/" title="USFWS Science Applications Metadata Guidance"></iframe>
```

::: {.notes}
- Quarto can also create websites, such as this Science Applications Metadata Guidance.
- The course website that we are using today was created in Quarto.
:::


## Outputs: [Presentations]{.gray-bold}

```{=html}
<iframe width="1600" height="800" src="https://usfws.github.io/data-workflow-presentation/#/a-reproducible-data-workflow/" title="Presentation slides from a Reproducible Data Workflow presentation"></iframe>
```

::: {.notes}
- Quarto can also output professional-looking presentations as HTML-based Revealjs presentations or as PowerPoint. Templates are available online or with a little CSS code, you can create your own.
:::


## Outputs: [Books]{.gray-bold}

```{=html}
<iframe width="1600" height="800" src="https://r4ds.hadley.nz/" title="R for Data Science ebook"></iframe>
```

::: {.notes}
Finally, it's possible to write books using Quarto, such as the R for Data Science book shown here.

- To summarize, Quarto is an open-source scientific and technical publishing system.
- Instead of writing a report or presentation in Word, PowerPoint, etc.; then running code in an R script; then saving output and visualizations; and then pasting them in the report or the presentation
- We can do it all in Quarto, a free system especially tailored to scientific and technical publishing. 
:::


## Quarto and R Markdown

:::{.fragment}
![](images/render1.png){height=800 fig-alt="A diagram showing the process of rendering a document using R Markdown."}
:::

::: {.notes}
- How does it work? If you are familiar with R Markdown, you are probably familiar with this pipeline.
- You start out with an R Markdown document, which includes text and R code.
:::


## Quarto and R Markdown

![](images/render2.png){height=800 fig-alt="A diagram showing the process of rendering a document using R Markdown."}  

::: {.notes}
- When you knit an R Markdown file, a R package "knitr" calls the engine knitr to execute your R code, and create an Markdown file that include and then uses Pandoc to produce whatever output you’ve specified.
:::

## Quarto and R Markdown

![](images/render3.png){height=800 fig-alt="A diagram showing the process of rendering a document using R Markdown."}  

::: {.notes}

:::


## Quarto and R Markdown

:::{.fragment}
![](images/render4.png){height=800 fig-alt="A diagram showing the process of rendering a document using Quarto."}  
:::

::: {.notes}
- A Quarto .qmd file on the other hand can be composed of text and R, Python, and/or Julia code. 
:::


## Quarto and R Markdown

![](images/render5.png){height=800 fig-alt="A diagram showing the process of rendering a document using Quarto."}  

::: {.notes}
- Either the knitr or jupyter engines will then render your text and code into a Markdown file followed by Pandoc producing whatever output you’ve specified.
Quarto accomplishes this by being fully separate from the R ecosystem. You can even run it from the command-line interface (i.e., the shell or terminal), if you want to. 
:::


## Quarto and R Markdown

![](images/render6.png){height=800 fig-alt="A diagram showing the process of rendering a document using Quarto."}  

::: {.notes}

- Embedding code and output from Python, R, and JavaScript via integration with Jupyter, Knitr, and Observable.

- A variety of extensions to Pandoc markdown useful for technical writing including cross-references, sub-figures, layout panels, hoverable citations and footnotes, callouts, and more.

- A project system for rendering groups of documents at once, sharing options across documents, and producing aggregate output like websites and books.

- Authoring using a wide variety of editors and notebooks including JupyterLab, RStudio, and VS Code.

- A visual markdown editor that provides a productive writing interface for composing long-form documents.
:::


## When to use Quarto and R Markdown? 

::: columns

::: {.column width="40%"}

\

::: {.incremental}
- Weave together text, plots, tables, and statistics
- Frequently re-create a standardized document
- Reproduce your analyses
- Generate comparable reports across multiple parameters (species, watershed, state)
:::

:::

::: {.column width="60%"}
![](images/plover_thinking.png){height=800 fig-alt="An cartoon of a snowy plover thinking. There is a question mark above it's head."}
:::

:::

::: {.notes}

:::


## {background-image="images/plover_decision.png" background-size=contain}

::: {.notes}
You're at a crossroads! How do you decide whether to move from R Markdown to Quarto?
:::

## Advantage of R Markdown

::: columns

::: {.column width="40%" .incremental}
\

- Have existing R Markdown code that works for you
- Custom tools built around R Markdown that are not yet available in Quarto
:::

::: {.column width="60%"}
![](images/rmarkdown_packages.png){fig-align=center height=750 .drop}
:::

:::

::: {.notes}
- If you like using R Markdown, there’s no need to switch! R Markdown will continue to be supported and work as it always has been. You’re welcome to try Quarto if you like, but there’s no need to switch. 
- If you have a R Markdown file that includes custom tools, there is a chance that they might not yet in available in Quarto. If this is the case, you're of course welcome to stick with R Markdown. As they say, if it ain't broke, don't fix it.
:::


## Advantages of Quarto

::: columns

::: {.column width="60%"}

:::{.incremental}
- No requirement for R
- Fewer package dependencies
- revealjs slides are easier to work with
- Better cross referencing of figures, tables, and citations
- Quarto extensions allow for easier customization
- Quarto projects make it easier to customize websites and collaborate
- The future
:::

:::

::: {.column width="40%"}
![](images/quarto.png){.drop}
:::

:::

::: {.notes}
- That said, there are a number of advantage to using Quarto, including:
  - No requirement for R (multilingual)
    - R, Python, Julia, Javascript
  - More streamline and less R package dependencies
    - Use revealjs directly for pretty slides, rather than relying on R packages.
  - Cross referencing tables and tables in the text is more straightforward, as is inserting and managing citations.
  - A growing number of Quarto extensions add functionality
    - Allow you use customized templates and 
  - Quarto projects
    - Easier to create websites, books, collaborate on projects, etc.
  - Most active development has moved from R Markdown to Quarto. It will only get better with time.
:::


## Three ways to render Quarto

\

::: columns

::: {.column width="32%" .center}
::: {.fragment fragment-index=1}
### 1.  
**RStudio GUI**
![](images/quarto_render1.png){fig-alt="A screenshot of a Quarto document in RStudio. The Render button is circled in red" .drop}
:::
:::

::: {.column width="32%" .center}
::: {.fragment fragment-index=2}
### 2.   
**Quarto command line interface (CLI)**
![](images/quarto_render2.png){fig-alt="A screenshot of the command line terminal in RStudio. quarto render is typed in." .drop}
:::
:::

::: {.column width="36%" .center}
::: {.fragment fragment-index=3}
### 3. 
**Quarto R package**

::: {.small}
```r
quarto::quarto_render(input = ___, 
                      output_format = ___)
```
:::

:::
:::

:::

::: {.notes}

:::


## Authoring: Source and Visual panes

::: columns
::: {.column width="50%" .center}
![](images/source_pane.png){fig-alt="A screenshot of a Quarto document in RStudio viewed as Source." .drop}
:::

::: {.column width="50%" .center}
![](images/visual_pane.png){fig-alt="A screenshot of a Quarto document in RStudio viewed as Visual." .drop}
:::
:::

::: {.notes}

:::


# Exercise 1: [Rendering](exercises.qmd#sec-exercise1){target="_blank"} {.exercise}

\
\
\

```{r}
countdown::countdown(10, bottom = 0)
```

::: {.notes}

:::


# Anatomy of a Quarto File {.dark}

::: {.notes}

:::


## ![](images/quarto_example1.png)

::: {.notes}

:::


## YAML header

**Y**et **A**nother **M**arkup **L**anguage = document metadata!

::: columns

::: {.column width="50%"}

::: {.fragment}
```{yml}
#| echo: TRUE
#| eval: FALSE

---
title: "Introduction to Quarto"
author: "FWS staff"
format: 
  revealjs:
    theme: [default, refuge_light.scss]
    subtitle: "Overview"
    height: 900
    width: 1600
editor: source
---
```
:::

:::

::: {.column width="50%" .small .incremental}
- Starts and ends with "\-\-\-"
- Uses key-value pairs: `key: value`
  - *Picky about spacing and indentations!*
- Processed during rendering
- Including options for:
  - Title, authors, date
  - File output(s) (e.g., `html`, `docx`)
  - Styling (e.g., `theme`, `fig-width`)
  - Parameters
:::

:::


::: {.notes}

:::


## YAML header: [Options]{.gray-bold} 

::: {.incremental}
- Options are dependent on the file output (**many** options {{< fa face-flushed >}})  
- Search the [Quarto guidance](https://quarto.org/docs/reference/) within your specified file format:

::: {.fragment}
```{=html}
<iframe width="1600" height="500" src="https://quarto.org/docs/reference/formats/docx.html" title="Quarto HTML Options guidance"></iframe>
```
:::

:::

::: {.notes}

:::


## YAML header: [Options]{.gray-bold}

::: columns

::: {.column width="50%"}
::: {.callout-tip}
## Another option: Use your friendly assistant!
- Start a word and hit <kbd>`tab`</kbd> to complete or ...
- Type <kbd>`Ctrl+space`</kbd> to see available options.
:::
:::

::: {.column width=50%"}

![](images/yml_assistant.png){fig-alt="A screenshot of a yaml for a quarto document in RStudio showing the drop-down menu with options available."}
:::

:::

::: {.notes}

:::



# Exercise 2: [YAML metadata](exercises.qmd#sec-exercise2){target="_blank"} {.exercise}

\
\
\

```{r}
countdown::countdown(10, bottom = 0)
```

::: {.notes}

:::


## Text body: Markdown

::: columns

::: {.column width="50%"}
![](images/markdown.png){height="90%"}
:::

::: {.column width="50%" .incremental}
- Markdown is a markup language (e.g., HTML, teX, XML)
  - Add syntax to the text to change it's look
  - Mix text with markup instructions
- Quarto uses Pandoc Markdown
    - Inline or block elements
:::

:::

::: {.notes}
- Now we are going to get into the body of our Quarto file
- Everything in the body, aside from our code, which we will get to later, is written in the language Markdown
  - Allows us to write our text and do our styling in a machine-readable fashion
  - Luckily, it is pretty human-readable as well
- Essentially, it is how we make our document pretty
- Quarto uses Pandoc Markdown, which is very similar to but a little different from standard Markdown
  - One of the key features of Pandoc Markdown
  - Allows us to style inline elements without impacting surrounding text or other elements
  - OR style whole blocks of the document at once
  - And I’ll show you what I mean by this in a second
- We view our Quarto file in Markdown language when we use the “Source Editor”
  - And I’ll be walking through Quarto’s Markdown syntax
  - However, it’s important to acknowledge that you can do the same things in the “Visual Editor” by highlighting things and clicking buttons much like you would when formatting your document in Microsoft word
  - Both are acceptable, and you can toggle between them, but it’s always good to know the markdown because it gives you a little bit more control and can be really beneficial if your formatting gets wonky in the visual mode

:::


## Text body

::: columns

::: {.column width="50%"}
### Inline elements

- Individual words in a sentence
- Images, links, equations, or code in a sentence
:::

::: {.column width="50%"}
### Block elements 

- Paragraphs or sections of a document
- Standalone images, equations, or figures
:::

:::

::: {.notes}
- If we want to style (such as italicizing) certain words within a sentence or paragraph, this would be inline styling
- Aside from text, we can also include and style images, hyperlinks, equations, and code inline

:::


## Inline elements: [Text]{.gray-bold}

\
 
::: columns

::: {.column width="50%"}

### Markdown  

\

```{.markdown}
This is an example of how you could change    
inline elements of text body Markdown in a FWS  
report. You can make a word *italicized* or  
**bold**. You can also display code, such as 
`exp(10) + 1`. You can even ~~strikethrough~~  
and make something a superscript^1^.
```
:::

::: {.column width="50%"}

### Output  
::: {.fragment}
::: {.small}
This is an example of how you could change  
inline elements of text body Markdown in a FWS 
report. You can make a word *italicized* or  
**bold**. You can also display code, such as  
`exp(10) + 1`. You can even ~~strikethrough~~  
and make something a superscript^1^.
:::
:::

:::

:::

::: {.notes}
- Here’s an example showing a lot of the different options for customizing your text through inline changes
- You can use ___ for ___, …
  - Asterix, double asterix, backtick, double tilde, caret
  - You can also have inline code that is actually executed, but that’s getting outside of markdown language and styling, so we’ll come back to that later
  - Essentially you will add characters to denote certain types of styling and you want to place them at both the beginning and the end so that the computer knows where to start and stop the styling

:::


## Inline elements: [Math]{.gray-bold}

with LaTex!
 
::: columns

::: {.column width="50%"}

### Markdown  
```{.markdown}
The solution to $sqrt(x) = 26$ is $x = 676$ and  
$\pi = 3.1415...$.
```
:::

::: {.column width="50%"}

### Output 
::: {.fragment}
::: {.small}
The solution to $sqrt(x) = 26$ is $x = 676$ 
and $\pi = 3.1415...$.
:::
:::

:::

:::

::: {.notes}
- To make your equations look nice, you can use LaTex, which is coded using the dollar sign
:::


## Inline elements: [Hyperlinks and images]{.gray-bold}

\
 
::: columns

::: {.column width="50%"}
### Markdown  
  
```markdown
For more information on how to use Quarto,  
check out the [Quarto webpage](www.quarto.com).
```
  
\

::: {.fragment fragment-index=2}
```markdown
Here's an image that is inline with  
my text ![](images/favicon.png).
```
:::

:::

::: {.column width="50%"}
### Output
::: {.small}
::: {.fragment fragment-index=1}
For more information on how to use Quarto,  
check out the [Quarto webpage](www.quarto.com).
:::

\

::: {.fragment fragment-index=3}
Here's an image that is inline with  
my text ![](images/favicon.png){.center-inline}.
:::
:::

:::

:::

::: {.notes}
- Hyperlinks use square brackets for the display text, immediately followed by the URL in parentheses
  - So, “Quarto Webpage” is now a clickable link
- Images are similar, but require an exclamation mark at the beginning
  - Adding text in the square brackets is optional if you want to add alt text, but it will not display
  - In parentheses, we provide the path to the file

:::


## Block elements: [Paragraphs]{.gray-bold}

::: columns
:::{.column width="50%"}
### Markdown

``` markdown
Here's a paragraph. To separate it from the next  
paragraph, you need to add one or more empty lines.

This is a new paragraph. You can format each  
paragraph independently. A paragraph is an  
examine  of a block element.

::: {.callout-tip}
## Custom block element  

Here's an example of a block with custom 
formatting. Everything in this block has 
this format.
:::
```
:::

:::{.column width="50%"}

### Output  

:::{.small}
:::{.fragment}

Here's a paragraph. To separate it from the next paragraph,
you need to add one or more empty lines.

This is a new paragraph. You can format each paragraph independently. 
A paragraph is an examine of a block element.

::: {.callout-tip}
## Custom block element

Here's an example of a block with custom formatting. Everything in this block has this format.
:::

:::
:::

:::
:::


::: {.notes}
- Spacing is really important in Markdown language
- Creating paragraphs is super easy, you just need to remember to insert empty space between your blocks
- To style a block of text (could be one paragraph, could be multiple), enclose them in triple colons to define the section, and provide styling information in curly braces
- We’re not going to go deep into this, but if you have a custom styling scss file, you could apply a class you’ve defined to this block here
  - In this example, we format this block as a callout block
  - These callouts are just a built-in feature of Quarto
    - There are 5 types of callouts (note, tip, warning, caution, and important) – this example is a tip
    - And they all have their own color and icon
    - When we add a header to the block, quarto knows to make that text the banner in the callout
- In general, nesting styling is also possible. You can create blocks within blocks

:::


## Block elements: [Headers]{.gray-bold} 

\

+---------------------+-----------------------------------+
| Markdown Syntax     | Output                            |
+=====================+===================================+
|     # Header 1      | # Header 1 {.heading-output}      |
+---------------------+-----------------------------------+
|     ## Header 2     | ## Header 2 {.heading-output}     |
+---------------------+-----------------------------------+
|     ### Header 3    | ### Header 3 {.heading-output}    |
+---------------------+-----------------------------------+
|     #### Header 4   | #### Header 4 {.heading-output}   |
+---------------------+-----------------------------------+

::: {.notes}
- Headers are similar to headers in Word where there are different levels corresponding to text size and boldness
- The header level is indicated by the number of hashtags you use
  - So if you use 1 hashtag, it is a level 1 header, and so on

:::


## Block elements: [Lists]{.gray-bold}

\

::: columns

::: {.column width="50%"}
### Markdown 

```{.markdown}
**Ordered List**

1. This item first
2. Then this one
3. And finally this
```

\ 

::: {.fragment fragment-index=2}
```{.markdown}
**Unordered List**

- Kodiak Refuge
- Togiak Refuge
- Arctic Refuge
```
:::

:::

::: {.column width="50%"}

### Output

::: {.small}
::: {.fragment fragment-index=1}
**Ordered List**

1. This item first
2. Then this one
3. And finally this
:::

::: {.fragment fragment-index=3}
**Unordered List**

- Kodiak Refuge
- Togiak Refuge
- Arctic Refuge
:::
:::

:::

:::

::: {.notes}
- Lists are pretty straightforward
  - A numbered list is made exactly how you would expect it to be
  - Standard bullet points are indicated with dashes
- You just want to be careful of spacing and choice of characters here

:::


## Block elements: [Math]{.gray-bold}

with LaTex!
 
::: columns

::: {.column width="50%"}

### Markdown  
```{.markdown}
The Cauchy-Schwarz Inequality

$$
\left( \sum_{k=1}^n a_k b_k \right)^2 
\leq 
\left( \sum_{k=1}^n a_k^2 \right) 
\left( \sum_{k=1}^n b_k^2 \right)
$$
is an upper bound on the inner product between  
two vectors in an inner product space in terms  
of the product of the vector norms.
```
:::

::: {.column width="50%"}

### Output  

:::{.fragment}
::: {.small}
The Cauchy-Schwarz Inequality

$$
\left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)
$$
is an upper bound on the inner product between two vectors in an inner product space in terms of the product of the vector norms.
:::
:::

:::

:::

::: {.notes}
- To write out more substantial equations, you do the same thing as before, but use double dollar signs to enclose the LaTex block
- Everything within the block is actually not Markdown
  - It’s LaTex code, which is another markup language
  - So to know how to write out these equations, you’ll want to Google a LaTex guide

:::


## Block elements: [Images]{.gray-bold}

\

::: columns

::: {.column width="50%"}
### Markdown
```{.markdown}
Here's a paragraph of text. We describe
something of great importance. So great,
in fact, that we need to also include an image. 

![](images/bear_singing.png)

Moving along, we will describe something else. 
```
:::

::: {.column width="50%"}
### Output
::: {.small .fragment}
Here's a paragraph of text. We describe  
something of great importance. So great,  
in fact, that we need to also include an image. 

![](images/bear_singing.png){width="30%"}

Moving along, we will describe something else. 
:::
:::

:::

::: {.notes}
- To add an image on its own line, it is exactly the same as before
- Just add empty lines before and after to make it clear that the image should be treated as its own block

:::


# Exercise 3: [Document body](exercises.qmd#sec-exercise3){target="_blank"} {.exercise}

\
\
\

```{r}
countdown::countdown(10, bottom = 0)
```

::: {.notes}

:::


## Code chunks: [Pandoc]{.gray-bold}

::: columns

::: {.column width="50%"}  
````markdown
```language
Some code here
```
````
:::

::: {.column width="50%"}
:::{.small .incremental}
- Code chunk surrounded by a "fence" of three backticks ` ``` `
- Specifying the language allows for syntax highlighting.
- Code is displayed but not executed
:::
:::

:::

::: {.notes}
In this section, we'll delve into one of the final elements of a Quarto document: inline code and code blocks, commonly known as code chunks.

These components enable us to seamlessly integrate data analyses, visualizations, and computations right within the Quarto document, enhancing the interactive experience and improving reproducibility.

Let's break down the structure of a code chunk and walk through its processing:

Code chunks are defined by enclosing the code within three backticks (```). This notation signals to Pandoc that the content between these backticks is code and should not be treated as regular text. 

Following the initial three backticks, we indicate the programming language of the code. This helps Pandoc understand how to interpret the code.
:::


## Code chunks: [R Markdown]{.gray-bold} {auto-animate="true"}

::: columns

::: {.column width="50%"}
    ```{{r, echo=FALSE}}
    Some code here
    ```
:::

::: {.column width="50%"}
::: {.small}
- Code chunk surrounded by a "fence" of three backticks ` ``` `  
- Specifying the language allows for syntax highlighting.
- ~~Code is displayed but not executed~~ Code executes unless you specify as an option -> brackets`{}`
- Chunk options are a comma-separated list (R syntax)
:::
:::

:::

::: {.notes}
The language specification must be enclosed in curly brackets to denote which programming language is being used for execution.

For those of you familiar with RMarkdown, you might recall that code chunk options were traditionally included in the curly brackets after specifying the r language, using commas to separate each option.
:::


## Code chunks: [Quarto]{.gray-bold} {auto-animate="true"}

::: columns

::: {.column width="50%"}
    ```{{language}}
    #| echo: false
    
    Some code here
    ```
:::

::: {.column width="50%"}
::: {.small}
- Code chunk surrounded by a "fence" of three backticks ` ``` `
- Specifying the language allows for syntax highlighting.
- ~~Code is displayed but not executed~~ Code executes unless you specify as an option -> brackets`{}`
- ~~Chunk options are a comma-seperated list (R syntax)~~ Chunk options moved to a YAML in the cell after a hash pipe `#|`
    + Wider language support
    + Easier to read
:::
:::

:::

::: {.notes}
In Quarto, while the language is still specified in the curly brackets, the chunk options are organized in a YAML format within the cell. Each option is placed on its own line, prefaced by hashtags and pipes, making the code chunk more readable and supporting a variety of programming languages.

For those of you not familiar with code chunk options, don't worry, we'll cover these in a minute. 
:::


## Code chunks: [Labels]{.gray-bold} {auto-animate="true"}

\

::: columns

::: {.column width="50%"}
- Identifies code chunks
    - Makes debugging easier
    - Can reference code chunk outputs in the text
:::

::: {.column width="50%" .fragment}
\

```{{r}}
label: summary-plot

Some code to generate a plot...
```
:::

:::

\

::: {.fragment}
:::{.callout-tip title="Avoid using underscores (_) in labels and IDs."}
This can cause problems when rendering to PDF with LaTeX. {{< fa face-smile-wink >}}
:::
:::

::: {.notes}
Another significant improvement in Quarto is the inclusion of code chunk labels within the YAML of the cell instead of the curly brackets. 

Labeling chunks enhances document organization, simplifies debugging, and facilitates referencing code chunk outputs in the text, which is especially valuable for creating figures and tables in manuscripts or reports.

A best practice to keep in mind is to refrain from using underscores in code chunk labels, as this can lead to rendering issues, particularly with LaTeX.
:::


## Execution options: [Outputs]{.gray-bold}

\

::: {.small}
| Option    | Description                                                                                                                                                                                       |
|-----------|------------------------------------------------------------|
| `eval`    | Evaluate the code chunk (if `false`, just echos the code into the output).                                                                                                                        |
| `echo`    | Include the source code in output                                                                                                                                                                 |
| `output`  | Include the results of executing the code in the output (`true`, `false`, or `asis` to indicate that the output is raw markdown and should not have any of Quarto's standard enclosing markdown).  |
| `warning` | Include warnings in the output.                                                                                                                                                                   |
| `error`   | Include errors in the output.                                                                                                                                                                     |
| `include` | Catch all for preventing any output (code or results) from being included (e.g. `include: false` suppresses all output from the code block).                                                  |
:::

\

:::{.fragment}
::: {.callout-tip title="Tab Completion is your friend!"}

:::
:::

::: {.notes}
Code chunk options are parameters that modify the behavior of code chunks in your Quarto documents. 

If the code throws and error or warning would you like them to be included in the resulting document? If your code produces a figure or table would you like them to be displayed? 

These options can control various aspects of code execution and output display.

Having trouble remembering all of the options available to you? In Rstudio if you hit the tab key after the hashpipe a dropdown menu with available options is provided.
:::

## Execution options: [Figures]{.gray-bold} {auto-animate="true"}

::: columns
::: {.column width="50%"}
```{{r}}
library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")
```
:::

::: {.column width="50%" .fragment}
```{r}
#| echo: true

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")
```
:::
:::


::: {.notes}
Let's walk through an example together.

In this code chunk we specify our coding language as r and use the ggplot package to plot petal width vs. petal length using the iris data.

When we render this document our output will produce the code, the figure the code generated, and any error or warnings the code could encounter.
:::


## Execution options: [Figures]{.gray-bold} {auto-animate="true"}

::: columns
::: {.column width="50%"}
```{{r}}
#| echo: false

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")
```
:::

::: {.column width="50%" .fragment}
```{r}
#| echo: false

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")
```
:::
:::


::: {.notes}
Let's run that same code chunk again but this time we'll include the echo = false code chunk option.

By adding our echo option and specifying it as false, our output no longer includes the source code.
:::


## Execution options: [Figures]{.gray-bold} {auto-animate="true"}

::: columns
::: {.column width="50%"}
```{{r}}
#| echo: false
#| fig-width: 3
#| fig-height: 2

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")

```
:::

::: {.column width="50%" .fragment}
```{r}
#| echo: false
#| fig-width: 3
#| fig-height: 2

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")

```
:::
:::


::: {.notes}
We can also use code chunk options to adjust the width and height of the figure.
Here we set the figure width to 3 and the figure height to 2. 
:::


## Execution options: [Figures]{.gray-bold} {auto-animate="true"}

::: columns
::: {.column width="50%"}
```{{r}}
#| echo: false
#| fig-width: 5
#| fig-height: 5

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")
```
:::

::: {.column width="50%"}
```{r}
#| echo: false
#| fig-width: 5
#| fig-height: 5

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")

```
:::
:::


::: {.notes}
Or we can make the figure larger by setting the figure width and height to 5.
:::


## Execution options: [Figures]{.gray-bold} {auto-animate="true"}

::: columns
::: {.column width="50%"}
```{{r}}
#| echo: false
#| fig-width: 5
#| fig-height: 5
#| fig-cap: "This is my really neat plot."

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")

```
:::

::: {.column width="50%" .fragment}
```{r}
#| echo: false
#| fig-width: 5
#| fig-height: 5
#| fig-cap: "This is my really neat plot."

library(ggplot2)

ggplot(iris, aes(x = Petal.Width, 
                 y = Petal.Length)) +
  geom_point() +
  labs(x = "Petal width",
       y = "Petal length")

```
:::
:::

::: {.notes}
Let's add a caption to our figure using the fig-cap option. 
:::


## Execution options: [YAML]{.gray-bold} {auto-animate="true"}

\

::: columns

::: {.column width="60%"}
::: {.callout-tip title="Execution options at the document level in the YAML
"}
Avoids having to reapply options for each code chunk! {{< fa thumbs-up >}}
:::
:::

::: {.column width="40%" .fragment}
```yaml
---
title: "My FWS Report"
author: Jane Biologist
format: html
---
```
:::

:::

:::{.notes}
If you'd like to apply the same code chunk options to all code chunks throughout the document, you can add them in the document's YAML rather than adding them to every code chunk.
:::


## Execution options: [YAML]{.gray-bold} {auto-animate="true"}

\

::: columns

::: {.column width="60%"}
::: {.callout-tip title="Execution options at the document level in the YAML
"}
Avoids having to reapply options for each code chunk! {{< fa thumbs-up >}}
:::
:::

::: {.column width="40%"}
```yaml
---
title: "My FWS Report"
author: Jane Biologist
format:
  html:
    fig-width: 5
    fig-height: 5
execute:
  echo: false
---
```
:::

:::

:::{.notes}

:::


## Inline elements: [Code]{.gray-bold}

\

::: columns

::: {.column width="50%"}
### Source code  

```{source code}
#| echo: TRUE
#| eval: FALSE

This is an example of how you could use
code to calculate and report that the species
in the iris dataset with the longest sepal 
length is the 
`r iris[which.max(iris$Sepal.Length), "Species"]`.
```
:::

::: {.column width="50%"}

### Output  
::: {.fragment}
::: {.small}
This is an example of how you could use
code to calculate and report that species
in the iris dataset with the longest sepal
length is the `r iris[which.max(iris$Sepal.Length), "Species"]`.
:::
:::

:::

:::

::: {.notes}
The final concept we'll cover regarding code is inline code. Previously, we explored inline elements to modify font styles, embed images, and add hyperlinks; however, we can also incorporate code directly within the text of the document. To achieve this, we enclose the code in single backticks. After the initial backtick, we specify the code language, allowing Quarto to understand how to process the code. By using both inline code and code chunks, Quarto documents become highly dynamic and powerful tools for presenting information.
:::

# Exercise 4: [Code](exercises.qmd#sec-exercise4){target="_blank"} {.exercise}

\
\
\

```{r}
countdown::countdown(10, bottom = 0)
```


# Exercise 5: [Your turn](exercises.qmd#sec-exercise5){target="_blank"} {.exercise}

\
\
\

```{r}
countdown::countdown(10, bottom = 0)
```


## Wrap up

::: columns

::: {.column width="50%"}
![](images/quarto_space.png){width=700 fig-alt="A Quarto spaceship launching into space with documents and reports floating around it."}
:::

::: {.column width="50%"}
- Quarto is a powerful tool for creating scientific documents, presentations, and websites.
- Three basic components of a Quarto file control the rendered output:
    - YAML metadata
    - Text body
    - Code chunks
- Once you understand the basics,  the sky's the limit!
:::

:::

## {.center background-image="images/plover_question.png" background-size="contain"}

